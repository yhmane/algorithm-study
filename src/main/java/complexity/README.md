# 시간복잡도와 공간복잡도

---
## 성능 분석의 기준
프로그램의 성능을 측정하는데 기준은 무엇일까? 아래의 예시를 보고 한번 생각해보도록 하겠습니다.

```
A군은 특정 데이터 집단을 분석하여 모델링하는 알고리즘 a,b를 개발하였다
A군의 컴퓨터에서 a 알고리즘과 b 알고리즘을 수행하였더니, 각각 20분, 40분의 시간이 소요 되었다
A군은 또 다른 테스트를 하기위해 B서버와 C서버에서 각 알고리즘을 구행하였더니 40분, 30분의 시간이 소요 되었다
A군은 각각 다른 결과를 보고, 어떠한 알고리즘이 더 나은 성능을 나타내는지 판단을 보류하기로 하였다
```

위의 예시를 보면 A군이 개발한 a,b 알고리즘 중 어느것이 더 뛰어나다고 단정할 수 있을까?<br/>
아쉽지만 기준이 애마하기 때문에 어느것이 뛰어나도고 단정할 수 없습니다.<br/> 
그렇다면 우리는 알고리즘의 성능을 측정하는데 어떠한 기준을 적용하는 것일까? 답은 바로 아래에 나와 있습니다. 

* 시간복잡도
* 공간복잡도

컴퓨터 공학을 전공하였다면, 한번쯤은 들어봤을 개념입니다. 들어보지 않았다면, 이번 기회에 정리하는 시간을 갖도록 합시다!!<br/>
시간복잡도는 cpu, 공간복잡도는 memory와 관련되어 있다는 것만 짚고 넘어가고, 자세한건 밑에서 알아보도록 하겠습니다.

---
## 시간복잡도
> 시간복잡도란 무엇일까?<br/>
> 
> "In computer science, the time complexity is the computational complexity that describes the amount of computer time it takes to run an algorithm."

시간 복잡도(Time Complexity)란 특정 알고리즘이 문제를 해결하는데 걸리는 시간을 의미합니다.<br/>
같은 문제를 해결하는데 접근 방법이나 알고리즘에 따라 걸리는 시간이 달라질 수 있습니다.<br/>
따라서, 우리는 같은 문제를 해결하는데 더 적은 시간이 걸리는 알고리즘을 선택해야 합니다.

### 시간복잡도 표기법
시간복잡도를 표현하는 방법은 아래와 같이 3가지가 있습니다. 간단히 각 표기법에 대하여 알아보도록 하겠습니다.
* O (빅오,Big-O)
  * 최악의 경우를 나타냅니다. 즉, 최대로 걸릴 수 있는 시간(상한 시간)을 의미합니다
* Ω (빅오메가,Big-Omega)
  * 최선의 경우를 나타냅니다. 즉, 최소로 걸릴 수 있는 시간(하한 시간)을 의미합니다
* θ (빅세타,Big-Theta)
  * 최선과 최악의 중간을 나타냅니다. 즉 평균적인 복잡도를 의미합니다
    
3가지의 표기법을 제시하지만 알고리즘의 성능 측정 지표로 주로 사용되는 표기법은 빅오 표기법입니다.<br/>
그 이유인 즉슨 '아무리 최악의 상황이라도 상한시간의 성능을 보장할 수 있다'라는 것이기 때문이다.

### Big-O
위에서 간단히 시간복잡도를 측정하는 표기법에 대하여 알아보았습니다.<br/>
빅오표기법은, 문제 해결시 최대로 걸리는 시간 (최악의 시간)을 구하는데 사용됩니다.<br/>
주로 사용되는 시간복잡도에 대하여 간략히 알아보고 계산법에 대하여 예시를 통해 알아보도록 하겠습니다.

|이름|시간복잡도|수행횟수 예시|
|---|---|---|
|상수|O(1)|10|
|로그|O(log n)|log n, log(n^2)|
|선형|O(n)|n|
|선형로그|O(n log n)|n log n, log n!|
|2차|O(n^2)|n^2|
|3차|O(n^3)|n^3|
|지수|O(2^n)|1.1^n, 10^n|
|팩토리얼|O(n!)|n!|

시간복잡도 표기법에 대해서 알아보도록 하겠습니다.
```
T(n) = 10 = O(1)
T(n) = 2n^3 + 2n + 5 = O(n^3)
T(n) = 5n^4 + 2n^2 + 10 = O(n^4) 
```
시간복잡도는 가장 큰 영향력을 주는 항에 대해서만 빅오로 표기합니다. 다음은 코드로 보며 시간복잡도를 계산해보도록 하겠습니다.

* 예제 1)
```java
public void constant() {
    int constant = 100;
}
```
한번만 수행되기 때문에 위 함수의 시간복잡도는 O(1)입니다. 

* 예제 2)
```java
public void forTimeComplexity(int n) {
    int sum = 0;   
    for (int i = 0; i < n; i++) { // n + 1
        // 실행
    }
}
```
시간 복잡도는 O(n)입니다.

* 예제 3)
```java
public void forTimeComplexity(int n) {
    int sum = 0;                        
    for (int i = 0; i < n; i++) {       // n + 1
        for (int j = 0; j < n; j++) {   // n + 1
            // 실행
        }
    }
}
```
n^2 + 2n + 1이지만 가장 영향력을 많이 주는 n^2 항으로 계산하면 O(n^2)입니다.

간단한 예시로 시간복잡도를 계산해 보아는데요,<br/>
다음 정렬 포스팅에서 더욱 자세히 알아보도록 하겠습니다!!

---
## 공간복잡도
공간 복잡도(Space Complexity) 프로그램을 실행 후 완료하는 데 필요로 하는 자원의 양을 말합니다.<br/>
다만 최근에는 컴퓨터의 발달로 인해 충분한 메모리를 확보할 수 있기 때문에 공간복잡도의 중요성이 예전에 비해서 많이 낮아졌습니다.<br/>

```java
int get_factorial(int n) {
    int i = 0;
    int result = 1;
    
    for(i = 1; i <= n; i++)
    {
        result = result * i;
    }
    return result;
}
```
변수 i, result만 사용하므로 공간복잡도는 O(1)입니다.

```java
int get_factorial(int n) {
    if(n > 1) return n * factorial(n - 1);
    else return 1;
}
```
위와 같은 팩토리얼이지만, 재귀를 이용하고 있습니다. n부터 1까지 호출되어 스택에 쌓이므로 O(n)입니다.<br/>
가변공간을 잘 활용하고 재귀보다는 for문으로 풀어 주면 공간을 효율적으로 사용할 수 있는 것을 확인하였습니다.

---
## 정리
시간복잡도는 '얼마나 빠르게 수행되느냐?' 공간복잡도는 '얼마나 많은 자원을 사용하느냐'로 정리할 수 있습니다.<br/>
이전과는 달리 하드웨어의 급속한 발전으로 인해 어느정도의 시간복잡도만 보장해준다면 공간복잡도는 이해해주고 있습니다!!<br/>

다음 포스팅에서는 정렬 알고리즘에 대하여 알아보도록 하겠습니다!! 

---
### 참조
* [위키](https://en.wikipedia.org/wiki/Time_complexity)
* [코딩팩토리님의 블로그](https://coding-factory.tistory.com/608)
* [메모스텍님의 블로그](https://memostack.tistory.com/5)